---
title: "FinalProject.Rmd"
author: "Group 9"
date: "12/1/2017"
resource_files:
- .Renviron
output:
  html_document:
    code_folding: hide
    toc: yes
    toc_depth: 4
    toc_float: yes
runtime: shiny
---

```{r setup, include=TRUE}
knitr::opts_chunk$set(echo = TRUE)
require(data.world)
require(MASS)
require(ISLR)
require(dplyr)
require(ggplot2)
```

## Data Cleaning 
We initially had 20 tables to clean - so for simplicity's sake we will just show an example of how we cleaned a few of these twenty. 

```{r, eval = FALSE}
daycare	=	read_csv("/Users/amandale/Downloads/stcyngyn-fall-2017-edvproject-5/day_care_centers.csv", col_types = cols(
  place_id = col_character(),
  zipcode = col_integer(),
  place_type = col_character(),
  place_name = col_character(),
  latitude = col_double(),
  longitude = col_double(),
  website_url = col_character(),
  property_address = col_character(),
  map_url = col_character(),
  phone = col_character(),
  opening_hours = col_character()
))

daycare = daycare %>% dplyr::select(place_id, zipcode, place_type, place_name, latitude, longitude, opening_hours)

for(n in names(daycare)){
  daycare[n] <- data.frame(lapply(daycare[n], gsub, pattern="[^ -~]",replacement = ""))
}

write_csv(daycare, "/Users/amandale/Downloads/DataCleaning/daycarecenters.csv")

```

We also 


## Non SELECT * SQL

Import the data from data.world, where the bulk of the work is done on the back end.

```{r}
project <- "https://data.world/rc38246/f-17-edv-project-5"
data.world::set_config(cfg_env("DW_API"))
schools <- data.world::query(
  data.world::qry_sql("SELECT s.latitude AS slat, s.longitude AS slong, school_name, a.latitude AS alat, a.longitude AS along, apartment_name FROM schools AS s cross join apartments AS a WHERE s.grades = 'Elementary' and school_type = 'public'"),
  dataset = project
  )
places <- data.world::query(
  data.world::qry_sql("SELECT place_name, place, market_time, school_time FROM places JOIN times using(place_id)"),
  dataset = project
  )
zcta <- data.world::query(
  data.world::qry_sql("SELECT usa_zcta.zcta , usa_zcta.b25001_001 as housing_units , usa_zcta.b25058_001 as median_rent, usa_zcta.b25071_001 as rent_percentage_of_income
FROM usa_zcta"),
  dataset = project
)

zipcodes = c(30004,30005, 30009, 30012, 30013, 30017, 30021, 30023, 30024, 30028, 30030,30031,
             30032, 30033, 30034, 30035, 30038, 30039, 30040, 30043, 30047, 30052, 30058,
             30062, 30066, 30072, 30074, 30075, 30076, 30077, 30078, 30079)
zcta = zcta %>% dplyr::filter(is.element(zcta, zipcodes))

apartments <- data.world::query(
  data.world::qry_sql("SELECT apartments.apartment_name, apartments.latitude, apartments.longitude, apartments.place_id, apartments.zipcode
FROM apartments"),
  dataset = project
)

daycare <- data.world::query(
  data.world::qry_sql("SELECT daycarecenters.place_id, daycarecenters.zipcode, daycarecenters.place_type, daycarecenters.place_name,
daycarecenters.latitude, daycarecenters.longitude, daycarecenters.location, daycarecenters.opening_hours
FROM daycarecenters"),
  dataset = project
)

units <- data.world::query(
  data.world::qry_sql("SELECT * from units"),
  dataset = project
)

attach(schools)
attach(places)
```

## How many apartments are near how many public elementary schools?
Adjusting the slider below changes the range. If we set the slider to it's minimum value, we see that all apartments in the data set are within 1 km from a public elementary school. This means that the local municipalities did a good job of ensuring public education for their constituents.

Increasing the range causes the data to take a Boltzmann-like distribution, which means that the majority of apartments are near only a handful of schools, and the number of outliers decrease as you progress rightward on the graph. 

```{r echo=FALSE}
R = 6371
deg2rad <- function(deg) {(deg * pi) / (180)}
# Determines the curvilinear distance between two coordinates in km
distances <- schools %>% dplyr::mutate(dLat = deg2rad(slat-alat), dLon = deg2rad(slong-along), a = sin(dLat/2)*sin(dLat/2)+cos(deg2rad(slat))*cos(deg2rad(alat))*sin(dLon/2)*sin(dLon/2), c = 2*atan2(sqrt(a), sqrt(1-a)), dist = R*c) %>% dplyr::select(school_name,apartment_name,dist)

# How many schools are within 5 km of each apartment
# grouped <- distances %>% dplyr::filter(dist <= 1) %>% dplyr::group_by(apartment_name) %>% dplyr::summarise(num_schools = n())

# how many apartments are within 5 km of how many schools
# regrouped <- grouped %>% dplyr::group_by(num_schools) %>% summarise(num_apartments = n())
sliderInput("range", "Range (in km):", min = 1, max = 10, value = 5)

renderPlot({
  distances %>% dplyr::filter(dist <= input$range) %>% dplyr::group_by(apartment_name) %>% dplyr::summarise(num_schools = n()) %>% ggplot(aes(num_schools)) + geom_bar() + labs(x = "Number of Schools", y = "Number of Apartments")
})
# grouped <- data %>% dplyr::group_by(agent_key) %>% summarise(sum_with_offer = sum(calls_with_offer), sum_with_accept = sum(calls_with_accept), sum_offer_applied = sum(calls_offer_applied)) 
# 
# gathered <- grouped %>% tidyr::gather(variable,value, -agent_key)
# 
# renderPlot({
#   gathered %>% ggplot(aes(x = agent_key, y = value, color = variable)) + geom_smooth(se = FALSE)
# })
# 
# attach(grouped)
```

## dplyr Stuff

Looking into most successful agents and teams
topics coverered - piplines. select, mutate , group_by, summarize, arrange
```{r echo = FALSE}
# data_SA = data %>% dplyr::select(agent_key, agent_name, calls_with_accept, calls, team_lead_id) %>% dplyr::mutate(call_acceptance_rate = calls_with_accept / calls) %>% dplyr::group_by(agent_key, agent_name,team_lead_id) %>% dplyr::summarize(avg_calls_with_a = mean(calls_with_accept), avg_calls = mean(calls), avg_call_acceptance_rate = mean(call_acceptance_rate))
# 
# data_SA_sort = data_SA %>% dplyr::arrange(desc(avg_call_acceptance_rate))
# 
# data_SA_sort = data_SA %>% dplyr::arrange(avg_call_acceptance_rate)
# 
# teams = data_SA %>% dplyr::select(team_lead_id, avg_calls, avg_call_acceptance_rate) %>% dplyr::group_by(team_lead_id) %>% dplyr::summarize(mean(avg_calls), mean(avg_call_acceptance_rate))
# 
# renderPlot({
#   ggplot(data = teams, aes(x=`mean(avg_calls)`, y = `mean(avg_call_acceptance_rate)`)) + geom_line()
# })

```